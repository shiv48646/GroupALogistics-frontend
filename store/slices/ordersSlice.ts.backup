// store/slices/ordersSlice.ts - Enhanced Version
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';

// Enhanced Order interface
export interface OrderItem {
  id: number;
  name: string;
  quantity: number;
  price: number;
}

export interface Order {
  id: string;
  customerName: string;
  customerEmail: string;
  customerPhone: string;
  status: 'pending' | 'processing' | 'shipped' | 'delivered' | 'cancelled';
  total: number;
  items: OrderItem[];
  shippingAddress: string;
  orderDate: string;
  notes?: string;
  createdAt: string;
  updatedAt: string;
}

export interface OrderFilters {
  search: string;
  status: 'all' | 'pending' | 'processing' | 'shipped' | 'delivered' | 'cancelled';
  dateRange?: {
    startDate: string;
    endDate: string;
  };
}

export interface OrdersPagination {
  page: number;
  limit: number;
  total: number;
}

interface OrdersState {
  orders: Order[];
  isLoading: boolean;
  error: string | null;
  selectedOrder: Order | null;
  filters: OrderFilters;
  pagination: OrdersPagination;
}

const initialState: OrdersState = {
  orders: [],
  isLoading: false,
  error: null,
  selectedOrder: null,
  filters: {
    search: '',
    status: 'all',
    dateRange: undefined
  },
  pagination: {
    page: 1,
    limit: 10,
    total: 0
  }
};

// Async thunks for API calls
export const fetchOrders = createAsyncThunk(
  'orders/fetchOrders',
  async (_, { rejectWithValue }) => {
    try {
      // TODO: Replace with your actual API call
      // const response = await api.get('/orders');
      // return response.data;
      
      // Sample data for now
      const sampleOrders: Order[] = [
        {
          id: 'ORD-001',
          customerName: 'John Smith',
          customerEmail: 'john@example.com',
          customerPhone: '+1 234 567 8900',
          status: 'pending',
          total: 299.99,
          items: [
            { id: 1, name: 'Wireless Headphones', quantity: 1, price: 199.99 },
            { id: 2, name: 'Phone Case', quantity: 2, price: 50.00 }
          ],
          shippingAddress: '123 Main St, City, State 12345',
          orderDate: '2024-01-15',
          notes: 'Customer requested express delivery',
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        },
        {
          id: 'ORD-002',
          customerName: 'Sarah Johnson',
          customerEmail: 'sarah@example.com',
          customerPhone: '+1 234 567 8901',
          status: 'processing',
          total: 149.99,
          items: [
            { id: 3, name: 'Bluetooth Speaker', quantity: 1, price: 149.99 }
          ],
          shippingAddress: '456 Oak Ave, Town, State 67890',
          orderDate: '2024-01-14',
          notes: 'Gift wrapping requested',
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        },
        {
          id: 'ORD-003',
          customerName: 'Mike Davis',
          customerEmail: 'mike@example.com',
          customerPhone: '+1 234 567 8902',
          status: 'shipped',
          total: 399.97,
          items: [
            { id: 4, name: 'Smart Watch', quantity: 1, price: 299.99 },
            { id: 5, name: 'Watch Band', quantity: 2, price: 49.99 }
          ],
          shippingAddress: '789 Pine St, Village, State 13579',
          orderDate: '2024-01-13',
          notes: '',
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        }
      ];
      return sampleOrders;
    } catch (error: any) {
      return rejectWithValue(error.message);
    }
  }
);

export const createOrder = createAsyncThunk(
  'orders/createOrder',
  async (orderData: Omit<Order, 'id' | 'createdAt' | 'updatedAt'>, { rejectWithValue }) => {
    try {
      // TODO: Replace with your actual API call
      // const response = await api.post('/orders', orderData);
      // return response.data;
      
      const newOrder: Order = {
        ...orderData,
        id: `ORD-${Date.now()}`,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };
      return newOrder;
    } catch (error: any) {
      return rejectWithValue(error.message);
    }
  }
);

export const updateOrderAsync = createAsyncThunk(
  'orders/updateOrder',
  async ({ id, ...updateData }: Partial<Order> & { id: string }, { rejectWithValue }) => {
    try {
      // TODO: Replace with your actual API call
      // const response = await api.put(`/orders/${id}`, updateData);
      // return response.data;
      
      const updatedOrder: Order = {
        ...updateData as Order,
        id,
        updatedAt: new Date().toISOString()
      };
      return updatedOrder;
    } catch (error: any) {
      return rejectWithValue(error.message);
    }
  }
);

export const deleteOrderAsync = createAsyncThunk(
  'orders/deleteOrder',
  async (orderId: string, { rejectWithValue }) => {
    try {
      // TODO: Replace with your actual API call
      // await api.delete(`/orders/${orderId}`);
      return orderId;
    } catch (error: any) {
      return rejectWithValue(error.message);
    }
  }
);

const ordersSlice = createSlice({
  name: 'orders',
  initialState,
  reducers: {
    // Keep your existing reducers for backward compatibility
    setOrders: (state, action: PayloadAction<Order[]>) => {
      state.orders = action.payload;
      state.pagination.total = action.payload.length;
    },
    addOrder: (state, action: PayloadAction<Order>) => {
      state.orders.unshift(action.payload); // Add to beginning
      state.pagination.total += 1;
    },
    updateOrder: (state, action: PayloadAction<Order>) => {
      const index = state.orders.findIndex(order => order.id === action.payload.id);
      if (index !== -1) {
        state.orders[index] = { ...action.payload, updatedAt: new Date().toISOString() };
      }
      if (state.selectedOrder && state.selectedOrder.id === action.payload.id) {
        state.selectedOrder = action.payload;
      }
    },
    setLoading: (state, action: PayloadAction<boolean>) => {
      state.isLoading = action.payload;
    },
    setError: (state, action: PayloadAction<string | null>) => {
      state.error = action.payload;
    },
    
    // New enhanced reducers
    setSelectedOrder: (state, action: PayloadAction<Order | null>) => {
      state.selectedOrder = action.payload;
    },
    clearSelectedOrder: (state) => {
      state.selectedOrder = null;
    },
    setFilter: (state, action: PayloadAction<{ key: keyof OrderFilters; value: any }>) => {
      const { key, value } = action.payload;
      (state.filters as any)[key] = value;
    },
    clearFilters: (state) => {
      state.filters = {
        search: '',
        status: 'all',
        dateRange: undefined
      };
    },
    setPagination: (state, action: PayloadAction<Partial<OrdersPagination>>) => {
      state.pagination = { ...state.pagination, ...action.payload };
    },
    clearError: (state) => {
      state.error = null;
    },
    updateOrderStatus: (state, action: PayloadAction<{ orderId: string; status: Order['status'] }>) => {
      const { orderId, status } = action.payload;
      const order = state.orders.find(order => order.id === orderId);
      if (order) {
        order.status = status;
        order.updatedAt = new Date().toISOString();
      }
    },
    deleteOrder: (state, action: PayloadAction<string>) => {
      state.orders = state.orders.filter(order => order.id !== action.payload);
      state.pagination.total -= 1;
      if (state.selectedOrder && state.selectedOrder.id === action.payload) {
        state.selectedOrder = null;
      }
    }
  },
  extraReducers: (builder) => {
    builder
      // Fetch orders
      .addCase(fetchOrders.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchOrders.fulfilled, (state, action) => {
        state.isLoading = false;
        state.orders = action.payload;
        state.pagination.total = action.payload.length;
      })
      .addCase(fetchOrders.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
      
      // Create order
      .addCase(createOrder.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(createOrder.fulfilled, (state, action) => {
        state.isLoading = false;
        state.orders.unshift(action.payload);
        state.pagination.total += 1;
      })
      .addCase(createOrder.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
      
      // Update order
      .addCase(updateOrderAsync.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(updateOrderAsync.fulfilled, (state, action) => {
        state.isLoading = false;
        const index = state.orders.findIndex(order => order.id === action.payload.id);
        if (index !== -1) {
          state.orders[index] = action.payload;
        }
        if (state.selectedOrder && state.selectedOrder.id === action.payload.id) {
          state.selectedOrder = action.payload;
        }
      })
      .addCase(updateOrderAsync.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
      
      // Delete order
      .addCase(deleteOrderAsync.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(deleteOrderAsync.fulfilled, (state, action) => {
        state.isLoading = false;
        state.orders = state.orders.filter(order => order.id !== action.payload);
        state.pagination.total -= 1;
        if (state.selectedOrder && state.selectedOrder.id === action.payload) {
          state.selectedOrder = null;
        }
      })
      .addCase(deleteOrderAsync.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      });
  }
});

// Export actions (keeping old ones for backward compatibility)
export const {
  setOrders,
  addOrder,
  updateOrder,
  setLoading,
  setError,
  // New actions
  setSelectedOrder,
  clearSelectedOrder,
  setFilter,
  clearFilters,
  setPagination,
  clearError,
  updateOrderStatus,
  deleteOrder
} = ordersSlice.actions;

// Selectors
export const selectAllOrders = (state: { orders: OrdersState }) => state.orders.orders;
export const selectOrdersLoading = (state: { orders: OrdersState }) => state.orders.isLoading;
export const selectOrdersError = (state: { orders: OrdersState }) => state.orders.error;
export const selectSelectedOrder = (state: { orders: OrdersState }) => state.orders.selectedOrder;
export const selectOrdersFilters = (state: { orders: OrdersState }) => state.orders.filters;
export const selectOrdersPagination = (state: { orders: OrdersState }) => state.orders.pagination;

// Filtered orders selector
export const selectFilteredOrders = (state: { orders: OrdersState }) => {
  const { orders, filters } = state.orders;
  let filtered = [...orders];

  // Filter by search
  if (filters.search) {
    const searchLower = filters.search.toLowerCase();
    filtered = filtered.filter(order =>
      order.id.toLowerCase().includes(searchLower) ||
      order.customerName.toLowerCase().includes(searchLower) ||
      order.customerEmail.toLowerCase().includes(searchLower)
    );
  }

  // Filter by status
  if (filters.status && filters.status !== 'all') {
    filtered = filtered.filter(order => order.status === filters.status);
  }

  // Filter by date range
  if (filters.dateRange) {
    const { startDate, endDate } = filters.dateRange;
    filtered = filtered.filter(order => {
      const orderDate = new Date(order.orderDate);
      return orderDate >= new Date(startDate) && orderDate <= new Date(endDate);
    });
  }

  return filtered;
};

// Orders by status selector
export const selectOrdersByStatus = (state: { orders: OrdersState }) => {
  const orders = state.orders.orders;
  return {
    all: orders.length,
    pending: orders.filter(order => order.status === 'pending').length,
    processing: orders.filter(order => order.status === 'processing').length,
    shipped: orders.filter(order => order.status === 'shipped').length,
    delivered: orders.filter(order => order.status === 'delivered').length,
    cancelled: orders.filter(order => order.status === 'cancelled').length
  };
};

export default ordersSlice.reducer;